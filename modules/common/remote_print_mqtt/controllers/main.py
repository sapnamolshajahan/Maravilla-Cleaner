# -*- coding: utf-8 -*-
import base64
import logging

from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding

import odoo
from odoo import http
from odoo.api import Environment
from odoo.modules.registry import Registry
from ..config import REMOTE_PUBLIC_KEYS, TOPIC_BASE
from ..exceptions import BadToken, NoSuchJob
from ..publisher import PrintPublisher

_logger = logging.getLogger(__name__)


class RemotePrintController(http.Controller):
    """
    Services for remote_print_mqtt
    """

    @http.route("/remote_print_mqtt/remote-info", type="json", auth="none")
    def remote_info(self, hostname, queues, channel, signature):
        """
        Remote Agent info submission.

        :param hostname: remote print-server name
        :param queues: list of queues on the remote print-server
        :param channel: random string generated by server, used to construct for message-topic
        :param signature: signature for "channel"

        """
        usable_key = self._find_usable_key(channel, signature)

        topics = {}
        for queue in queues:
            topics[queue] = f"{TOPIC_BASE}/{channel}/{queue}"

        for dbname in odoo.service.db.list_dbs(True):
            cr = Registry(dbname).cursor()
            env = Environment(cr, 1, {})

            try:
                for queue in queues:
                    env["remote.print.mqtt.job.queue"].update_queue(hostname, queue, topics[queue], usable_key)
                cr.commit()
            except Exception as e:
                cr.rollback()
                raise e
            finally:
                cr.close()

        return {
            "topics": topics,
        }

    def _find_usable_key(self, message, b64_signature):
        """
        See if the signed message matches any of our permitted keys.
        """
        signature = base64.b64decode(b64_signature)

        for key_path in REMOTE_PUBLIC_KEYS:
            with open(key_path, "rb") as key_file:
                public_key = serialization.load_pem_public_key(key_file.read(), None)

            try:
                public_key.verify(
                    signature, bytes(message, "utf-8"),
                    padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH),
                    hashes.SHA256())
                _logger.debug(f"yup, it's key={key_path}")
                return key_path

            except InvalidSignature:
                _logger.debug(f"nope, it's not key={key_path}")

        raise Exception("No suitable key found")

    @http.route("/remote_print_mqtt/token", type="json", auth="none")
    def token(self, queue):
        """
        Agent's Request a queue-operation token; invoked on startup.

        The agent will be notified via the MQTT broker.

        :rtype: empty dict {}
        """
        publisher = PrintPublisher()

        for dbname in odoo.service.db.list_dbs(True):
            cr = Registry(dbname).cursor()
            env = Environment(cr, 1, {})

            try:
                qtoken, job_queues = env["remote.print.mqtt.token.queue"].create_for_queue(queue)
                cr.commit()  # record must be readable in the db before notification

                if qtoken:
                    publisher.notify_for_queue(dbname, qtoken, job_queues)

            except Exception as e:
                cr.rollback()
                raise e
            finally:
                cr.close()

        return {}

    @http.route("/remote_print_mqtt/list/<dbname>", type="json", auth="none")
    def list_jobs(self, dbname, token):
        """
        List outstanding jobs in a queue (identified by the queue-operation token).

        The arguments after 'dbname' are unpacked from the POST against the URL.

        :rtype: list of job-tokens
        """
        cr = Registry(dbname).cursor()
        env = Environment(cr, 1, {})

        try:
            qtoken = env["remote.print.mqtt.token.queue"].validate_token(token)
            if not qtoken:
                raise BadToken(f"bad token={token}")

            job_list = []
            for job in env["remote.print.mqtt.job"].jobs_for_queue(qtoken.queue):
                job_token = env["remote.print.mqtt.token.job"].create_for_job(job)
                job_list.append(job_token.token)

            _logger.debug(f"listed queue={qtoken.queue}")

            # take the opportunity to purge job and queue tokens as well
            env["remote.print.mqtt.token.queue"].purge_tokens()

            cr.commit()

        except Exception as e:
            cr.rollback()
            raise e
        finally:
            cr.close()

        return {
            "jobs": job_list,
        }

    @http.route("/remote_print_mqtt/job/<dbname>", type="json", auth="none")
    def job_read(self, dbname, token):
        """
        Get the Print-Job identified by the job-token

        The arguments after 'dbname' are unpacked from the POST against the URL.
        """
        cr = Registry(dbname).cursor()
        env = Environment(cr, 1, {})

        try:
            job = env["remote.print.mqtt.token.job"].job_by_token(token)
            if not job:
                raise NoSuchJob(f"bad token={token}")
            result = {
                "id": job.id,
                "queue": job.queue,
                "copies": job.copies,
                "data": base64.b64encode(job.data),
            }
            _logger.debug(f"done remote-job={job.id}, queue={job.queue}")
            job.unlink()

            cr.commit()

            return result

        except Exception as e:
            cr.rollback()
            raise e
        finally:
            cr.close()
